class FreeQueue{States={READ:0,WRITE:1};constructor(t,e=1){this.states=new Uint32Array(new SharedArrayBuffer(Object.keys(this.States).length*Uint32Array.BYTES_PER_ELEMENT)),this.bufferLength=t+1,this.channelCount=e,this.channelData=[];for(let t=0;t<e;t++)this.channelData.push(new Float32Array(new SharedArrayBuffer(this.bufferLength*Float32Array.BYTES_PER_ELEMENT)))}static fromPointers(t){const e=new FreeQueue(0,0),s=new Uint32Array(t.memory.buffer),a=new Float32Array(t.memory.buffer),r=s[t.bufferLengthPointer/4],i=s[t.channelCountPointer/4],h=s.subarray(s[t.statePointer/4]/4,s[t.statePointer/4]/4+2),n=[];for(let e=0;e<i;e++)n.push(a.subarray(s[s[t.channelDataPointer/4]/4+e]/4,s[s[t.channelDataPointer/4]/4+e]/4+r));return e.bufferLength=r,e.channelCount=i,e.states=h,e.channelData=n,e}push(t,e){const s=Atomics.load(this.states,this.States.READ),a=Atomics.load(this.states,this.States.WRITE);if(this._getAvailableWrite(s,a)<e)return this.printAvailableReadAndWrite(),!1;let r=a+e;if(this.bufferLength<r){r-=this.bufferLength;for(let e=0;e<this.channelCount;e++){const s=this.channelData[e].subarray(a),i=this.channelData[e].subarray(0,r);s.set(t[e].subarray(0,s.length)),i.set(t[e].subarray(s.length))}}else{for(let s=0;s<this.channelCount;s++)this.channelData[s].subarray(a,r).set(t[s].subarray(0,e));r===this.bufferLength&&(r=0)}return Atomics.store(this.states,this.States.WRITE,r),!0}pull(t,e){const s=Atomics.load(this.states,this.States.READ),a=Atomics.load(this.states,this.States.WRITE);if(this._getAvailableRead(s,a)<e)return this.printAvailableReadAndWrite(),!1;let r=s+e;if(this.bufferLength<r){r-=this.bufferLength;for(let e=0;e<this.channelCount;e++){const a=this.channelData[e].subarray(s),i=this.channelData[e].subarray(0,r);t[e].set(a),t[e].set(i,a.length)}}else{for(let e=0;e<this.channelCount;++e)t[e].set(this.channelData[e].subarray(s,r));r===this.bufferLength&&(r=0)}return Atomics.store(this.states,this.States.READ,r),!0}getBufferLength(){return this.bufferLength-1}hasEnoughFramesFor(t){const e=Atomics.load(this.states,this.States.READ),s=Atomics.load(this.states,this.States.WRITE);return this._getAvailableRead(e,s)>=t}hasEnoughSpaceFor(t){const e=Atomics.load(this.states,this.States.READ),s=Atomics.load(this.states,this.States.WRITE);return this._getAvailableWrite(e,s)>=t}_getAvailableWrite(t,e){return e>=t?this.bufferLength-e+t-1:t-e-1}_getAvailableRead(t,e){return e>=t?e-t:e+this.bufferLength-t}_reset(){for(let t=0;t<this.channelCount;t++)this.channelData[t].fill(0);Atomics.store(this.states,this.States.READ,0),Atomics.store(this.states,this.States.WRITE,0)}printAvailableReadAndWrite(){const t=Atomics.load(this.states,this.States.READ),e=Atomics.load(this.states,this.States.WRITE);console.log(this,{availableRead:this._getAvailableRead(t,e),availableWrite:this._getAvailableWrite(t,e)})}}export default FreeQueue;